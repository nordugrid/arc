#!@PYTHON@

from __future__ import print_function

import sys
import logging
import argparse
import ldap
import json
import re
import socket
import dns.resolver
import dns.update
import dns.query
import dns.tsigkeyring
from dns.exception import DNSException


#
# OUTPUT FORMATTING FUNCTIONS
#
def output_celist(endpoint_list, cmd_args):
    """Output the list of CE hostnames (JSON capable)"""
    celist = []
    for ce, ep in endpoint_list.items():
        if len(ep) > 0 or cmd_args.output_all:
            celist.append(ce)
    if cmd_args.json:
        print(json.dumps(celist))
    else:
        for ce in celist:
            print(ce)


def output_endpoints(endpoint_list, cmd_args):
    """Output the list of endpoints and its type (JSON capable)"""
    elist = []
    for _, ep in endpoint_list.items():
        for e in ep:
            if 's' not in e:
                elist.append(e)
            elif e['s'] != "0" or cmd_args.output_all:
                elist.append(e)

    if cmd_args.json:
        print(json.dumps(elist))
    else:
        for e in elist:
            print('{u:<60} : {t}'.format(**e))


def output_zonefile(endpoint_list, cmd_args):
    """Output the content of BIND zone file"""
    if cmd_args.json:
        logger.error('JSON format is not supported by archery formatter')
    if cmd_args.output_all:
        logger.debug('ARCHERY formatter includes all endpoints by default and ignore --output-all option')
    if cmd_args.domain is None:
        logger.error('Domain name (--domain) is required to generate zonefile output for ARCHERY')
        sys.exit(1)

    _archery_rr_template = '{selector:<64}{ttl:>6} TXT "u={url} t={type}{inactive}"'
    ttl = 300

    a_pointers = []
    a_endpoints = []
    archery_selector = '_archery.{}.'.format(cmd_args.domain)
    for hostname, endpoints in endpoint_list.items():
        ce_selector = '{}._archery.{}'.format(hostname, cmd_args.domain)
        if len(endpoints) > 0:
            a_pointers.append(_archery_rr_template.format(selector=archery_selector,
                                                          ttl=ttl, url='u=dns://' + ce_selector,
                                                          type='org.nordugrid.archery', inactive=''))
            for e in endpoints:
                status = ''
                if 's' in e and e['s'] != 1:
                    status = ' s={}'.format(e['s'])
                a_endpoints.append(_archery_rr_template.format(selector=ce_selector, ttl=ttl,
                                                               url=e['u'], type=e['t'],
                                                               inactive=status))
    print('; pointers to CE endpoints')
    for p in a_pointers:
        print(p)
    print('; CE endpoints')
    for e in a_endpoints:
        print(e)

_output_formatters = {
    'CEs': output_celist,
    'endpoints': output_endpoints,
    'archery': output_zonefile
}


#
# ENDPOINT FILTERING CLASSES
#
class EndpointFilter(object):
    """Abstract interface class for implementing endpoint filters"""
    def filter(self, endpoint_dict):
        raise NotImplementedError('Filter function should be implemented (return True is for filtering)')

    def help(self):
        raise NotImplementedError('Help function should be implemented')


class EndpointFilterType(EndpointFilter):
    """Filter endpoints by type"""
    _all_endpoint_types = [
        'org.nordugrid.gridftpjob',
        'org.nordugrid.ldapglue1',
        'org.nordugrid.ldapglue2',
        'org.nordugrid.ldapng',
        'org.nordugrid.wsrfglue2',
        'org.ogf.bes',
        'org.ogf.glue.emies.activitycreation',
        'org.ogf.glue.emies.activityinfo',
        'org.ogf.glue.emies.activitymanagement',
        'org.ogf.glue.emies.delegation',
        'org.ogf.glue.emies.resourceinfo',
        'org.nordugrid.arcrest',
        'resourceinfo'
    ]
    _resourseinfo_endpoint_types = [
        'org.nordugrid.ldapglue2',
        'org.nordugrid.ldapng',
        'org.ogf.glue.emies.resourceinfo'
    ]

    def __init__(self, args='resourceinfo'):
        self._allowed_endpoint_types = args.split(',')
        # handle resourceinfo alias for all information endpoint types
        if 'resourceinfo' in self._allowed_endpoint_types:
            self._allowed_endpoint_types += self._resourseinfo_endpoint_types
            self._allowed_endpoint_types.remove('resourceinfo')
        for e in self._allowed_endpoint_types:
            if e not in self._all_endpoint_types:
                logger.critical('Wrong endpoint type \'%s\' passed to filter. Possible values are %s',
                                e, ','.join(self._all_endpoint_types))
                sys.exit(1)
        logger.debug('Applying endpoints filtering with the following allowed types: %s',
                     ','.join(self._allowed_endpoint_types))

    def filter(self, endpoint_dict):
        logger.debug('Endpoint type filter: checking %s (type %s) complies filter definition',
                     endpoint_dict['u'], endpoint_dict['t'])
        if endpoint_dict['t'] not in self._allowed_endpoint_types:
            logger.info('Endpoint %s of type %s filtered (type filter)', endpoint_dict['u'], endpoint_dict['t'])
            return True
        return False

    def help(self):
        print('Endpoint type filter: \'-f type:<endpoint type>[,<endpoint type>[...]]\'')
        print('\tThe following types are supported:\n\t\t{}'.format(
            ',\n\t\t'.join(self._all_endpoint_types)))


class EndpointFilterPortscan(EndpointFilter):
    """Filter endpoints by port connectivity check"""
    __uri_re = re.compile(r'^(?P<uri>(?:ldap|gsiftp|https)://(?P<host>[^:/]+):(?P<port>[0-9]+))/*.*')

    def __init__(self, args=None):
        self.__args = args

    def filter(self, endpoint_dict):
        uri_data = self.__uri_re.match(endpoint_dict['u'])
        if uri_data:
            uri_parms = uri_data.groupdict()
            s = socket.socket()
            address = uri_parms['host']
            port = int(uri_parms['port'])
            try:
                logger.debug('Portscan Filter: testing %s:%s connectivity.', address, port)
                s.settimeout(5)
                s.connect((address, port))
            except Exception as err:
                logger.info('Endpoint %s of type %s filtered (port connectivity filter). Exception is %s',
                            endpoint_dict['u'], endpoint_dict['t'], err)
                return True
            finally:
                s.close()
            return False
        else:
            logger.error('Endpoint %s of type %s filtered (port connectivity filter). Failed to parse URI.',
                         endpoint_dict['u'], endpoint_dict['t'])
            return True

    def help(self):
        print('Endpoint port connectivity filter: \'-f portscan\'')


class EndpointFilterAllowedVO(EndpointFilter):
    """Filter endpoints by allowed VO information in LDAP"""
    __uri_re = re.compile(r'^(?P<uri>(?P<protocol>ldap|https)://(?P<host>[^:/]+)(?P<port>:[0-9]+))/*.*')
    __ldap_uri_re = re.compile(r'^(?P<uri>ldap://(?P<host>[^:/]+)(?::[0-9]+))/(?P<basedn>.*)')

    def __init__(self, args=''):
        self._allowed_vos = args.split(',')

    def filter(self, endpoint_dict):
        ldap_uri = endpoint_dict['u']
        if endpoint_dict['t'] == 'org.nordugrid.ldapglue2':
            ldap_filter = '(&(objectClass=GLUE2AccessPolicy)(GLUE2AccessPolicyEndpointForeignKey={}))'.format(
                endpoint_dict['id'])
            ldap_attrs = ['GLUE2PolicyRule']
        elif endpoint_dict['t'] == 'org.nordugrid.ldapng':
            ldap_filter = '(objectClass=nordugrid-cluster)'
            ldap_attrs = ['nordugrid-cluster-acl']
        else:
            # for non-LDAP endpoints, like EMI-ES, LDAP GLUE2 queried for endpoint info
            uri_data = self.__uri_re.match(endpoint_dict['u'])
            if uri_data:
                uri_parms = uri_data.groupdict()
                ldap_uri = 'ldap://{}:2135/o=glue'.format(uri_parms['host'])
                ldap_filter = '(&(objectClass=GLUE2AccessPolicy)(GLUE2AccessPolicyEndpointForeignKey={}))'.format(
                    endpoint_dict['id'])
                ldap_attrs = ['GLUE2PolicyRule']
            else:
                logger.error('Endpoint %s of type %s filtered (allowed VO filter). Failed to parse URI.',
                             endpoint_dict['u'], endpoint_dict['t'])
                return True

        parse_ldap_uri = self.__ldap_uri_re.match(ldap_uri)
        if parse_ldap_uri:
            aris_params = parse_ldap_uri.groupdict()
            ldap_uri = aris_params['uri']
            ldap_basedn = aris_params['basedn']
            try:
                logger.debug('Allowed VO Filter: querying ARIS %s for allowed VOs', ldap_uri)
                ldap_conn = ldap.initialize(ldap_uri)
                # TODO: configurable ldap timeouts
                ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, 5)
                ldap_conn.set_option(ldap.OPT_TIMEOUT, 5)
                ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

                search_r = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_SUBTREE, ldap_filter, ldap_attrs)
                if search_r is None:
                    # it should not happens but just in case
                    return True
                for (_, volist) in search_r:
                    if ldap_attrs[0] not in volist:
                        return True
                    volist = [v.split(':', 1)[1] for v in volist[ldap_attrs[0]]]
                    for vo in self._allowed_vos:
                        if vo not in volist:
                            logger.info('Endpoint %s of type %s filtered (allowed VO filter)', endpoint_dict['u'],
                                        endpoint_dict['t'])
                            return True
            except ldap.LDAPError as err:
                logger.error('Endpoint %s of type %s filtered (allowed VO filter). '
                             'Failed to query LDAP endpoint %s to apply VO filter. Error: %s',
                             endpoint_dict['u'], endpoint_dict['t'], ldap_uri, err)
                return True
        return False

    def help(self):
        print('Endpoint allowed VO filter: \'-f vo:<voname>[,<voname>[...]]\'')


_filters = {
    'type': EndpointFilterType,
    'vo': EndpointFilterAllowedVO,
    'portscan': EndpointFilterPortscan
}


#
# INFORMATION SOURCES PROCESSING FUNCTIONS
#
def get_file_celist(fpath):
    """Load hostnames from static list stored in file"""
    ce_list = []
    try:
        with open(fpath, 'r') as fd:
            ce_list = [line.strip() for line in fd]
            return ce_list
    except EnvironmentError:
        logger.error('Failed to open file %s to read CE list', fpath)
    return ce_list


def get_egiis_celist(egiis_uri, ldap_timeout=5):
    """Fetch CE hostnames from EGIIS (for migration)"""
    ce_list = []
    ldap_uri_re = re.compile(r'^(?P<uri>ldap://[^:/]+(?::[0-9]+))/(?P<basedn>.*)')
    parse_egiis_uri = ldap_uri_re.match(egiis_uri)
    if parse_egiis_uri:
        egiis_params = parse_egiis_uri.groupdict()
        ldap_uri = egiis_params['uri']
        ldap_basedn = egiis_params['basedn']
    else:
        logger.error('Failed to parse provided EGIIS URL %s. '
                     'Expected format ldap://<egiishost>:<port>/mds-vo-name=<Country>,o=grid. ', egiis_uri)
        return ce_list

    try:
        ldap_conn = ldap.initialize(ldap_uri)
        ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

        logger.debug('Querying EGIIS: %s', egiis_uri)
        egiis_entries = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_BASE)

        if egiis_entries is None:
            logger.error('Querying EGIIS %s returns empty result set.', egiis_uri)
            return ce_list

        for egiis_dn, egiis_entry in egiis_entries:
            if egiis_dn.startswith('nordugrid-cluster-name='):
                ce_list.append(egiis_entry['Mds-Service-hn'][0])
            else:
                ce_list += get_egiis_celist('ldap://{Mds-Service-hn[0]}:2135/'
                                            '{Mds-Service-Ldap-suffix[0]}'.format(**egiis_entry), ldap_timeout)

    except ldap.LDAPError as err:
        logger.warning('Failed to query EGIIS %s. Error: %s', egiis_uri, err)
    return list(set(ce_list))


#
# ARIS ENDPOINTS PARSING FUNCTION
#
def get_ce_endpoints_glue2(hostname, port=2135, ldap_timeout=5, filters=None):
    """Get CE endpoints by querying ARIS GLUE2"""
    if filters is None:
        filters = []
    endpoints = []

    ldap_uri = 'ldap://{}:{}'.format(hostname, port)
    ldap_basedn = 'o=glue'
    ldap_filter = '(objectClass=GLUE2ComputingEndpoint)'
    ldap_attrs = ['GLUE2EndpointID', 'GLUE2EndpointURL', 'GLUE2EndpointHealthState', 'GLUE2EndpointInterfaceName']

    try:
        ldap_conn = ldap.initialize(ldap_uri)
        ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

        ldap_endpoints_list = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_SUBTREE, ldap_filter, ldap_attrs)
        if ldap_endpoints_list is None:
            logger.error('Querying LDAP GLUE2 for %s returns empty result set.', hostname)
            return endpoints

        for ldap_dn, ldap_ee in ldap_endpoints_list:
            if 'GLUE2EndpointURL' not in ldap_ee:
                logger.warning(
                    'Failed to find endpoint URL in LDAP response for DN %s. '
                    'It seams GLUE2 rendering is broken for %s.', ldap_dn, ldap_uri)
                continue
            # get endpoint data
            e_id = ldap_ee['GLUE2EndpointID'][0]
            e_url = ldap_ee['GLUE2EndpointURL'][0]
            e_type = ldap_ee['GLUE2EndpointInterfaceName'][0]
            e_entry = {'id': e_id, 'u': e_url, 't': e_type}
            if ldap_ee['GLUE2EndpointHealthState'][0].upper() != 'OK':
                e_entry['s'] = '0'
            # apply filters if any
            for fo in filters:
                if fo.filter(e_entry):
                    break
            else:
                # add endpoint if not filtered
                logger.debug('Found endpoint %s (type %s) for CE %s', e_url, e_type, hostname)
                endpoints.append(e_entry)
    except ldap.LDAPError as err:
        logger.error('Failed to query LDAP GLUE2 for %s. Error: %s', hostname, err)
    return endpoints


#
# ARCHERY INFO FETCHING FUNCTIONS
#
def parse_archery_txt(txtstr):
    """Get endpoint information dict from ARCHERY DNS TXT record"""
    endpoint = {}
    for kv in txtstr.split(' '):
        if kv[1] == '=':
            endpoint[kv[0]] = kv[2:]
        else:
            logger.debug('Malformed archery TXT entry %s (%s does not match k=value)', txtstr, kv)
    return endpoint


def get_archery_endpoints(archery, nameserver=None, resolver=None):
    """Get endpoints info from ARCHERY"""
    endpoints = {}
    # construct archery exact domain name to query
    if archery[0:6] == 'dns://':
        archery = archery[6:]
    else:
        archery = '_archery.' + archery
    # create DNS resolver
    if resolver is None:
        resolver = dns.resolver.Resolver()
        if nameserver is not None:
            resolver.nameservers = [nameserver]
    # query TXT records
    logger.debug('Querying ARCHERY endpoint: %s', archery)
    try:
        archery_rrs = resolver.query(archery, 'TXT')
        ttl = archery_rrs.rrset.ttl
        selector = str(archery_rrs.rrset.name)
        endpoints[selector] = {'txt': [], 'endpoints': []}
        for rr in archery_rrs:
            txt = ''.join(rr.strings)
            endpoints[selector]['txt'].append({'txt': txt, 'ttl': ttl})
            txtendpoint = parse_archery_txt(txt)
            endpoints[selector]['endpoints'].append(txtendpoint)
            # recursive query if needed
            if txtendpoint['t'] == 'org.nordugrid.archery':
                if 's' in txtendpoint and txtendpoint['s'] != '1':
                    continue
                endpoints.update(get_archery_endpoints(txtendpoint['u'], resolver=resolver))
    except DNSException as err:
        logger.warning('Failed to query ARCHERY endpoint %s. Error: %s', archery, err)

    return endpoints


#
# HANDLE DDNS UPDATE
#
def ddns_update(domain, nameserver, keyring_dict, endpoint_list, ttl=300):
    """Incrementally updates ARCHERY records in DNS"""
    keyring = dns.tsigkeyring.from_text(keyring_dict)
    main_selector = '_archery.{}.'.format(domain)

    # new endpoints according to provided list
    new_endpoints_set = set()
    for hostname, endpoints in endpoint_list.items():
        h_selector = '{}._archery.{}'.format(hostname, domain)
        if len(endpoints) > 0:
            new_endpoints_set.add('{} u=dns://{} t=org.nordugrid.archery'.format(main_selector, h_selector))
            for e in endpoints:
                status = ''
                if 's' in e and e['s'] != 1:
                    status = ' s={}'.format(e['s'])
                new_endpoints_set.add('{}. u={} t={}{}'.format(h_selector, e['u'], e['t'], status))

    # old endpoints from querying the ARCHERY
    old_endpoints_set = set()
    archery_endpoints = get_archery_endpoints('dns://' + main_selector, nameserver=nameserver)
    for selector, data in archery_endpoints.items():
        if domain not in selector:
            continue
        for txts in data['txt']:
            old_endpoints_set.add('{} {}'.format(selector, txts['txt']))

    # print(json.dumps(list(new_endpoints_set), indent=2))
    # print(json.dumps(list(old_endpoints_set), indent=2))

    remove_rr = old_endpoints_set - new_endpoints_set
    add_rr = new_endpoints_set - old_endpoints_set

    try:
        update = dns.update.Update(domain, keyring=keyring)
        for r in remove_rr:
            logger.debug('Going to REMOVE record by means of DDNS update: %s', r)
            rr = r.split(' ', 1)
            update.delete(rr[0], 'txt', rr[1].replace(' ', r'\ '))
        for a in add_rr:
            logger.debug('Going to ADD record by means of DDNS update: %s', a)
            ar = a.split(' ', 1)
            update.add(ar[0], ttl, 'txt', ar[1].replace(' ', r'\ '))
        logger.info('Sending update to DNS master %s via DDNS protocol (using TSIG key %s)',
                    nameserver, list(keyring_dict.keys())[0])
        dns.query.tcp(update, nameserver)
        # if exception is not raised we have succeeded with update
        logger.info('ARCHERY information has been updated for zone %s', domain)
    except DNSException as e:
        logger.error('Failed in DDNS update. Error: %s', e)

#
# MAIN EXECUTION CYCLE
#

# Initialize logger
logger = logging.getLogger('ARC.ARCHERY-Manage')
logger.setLevel(logging.WARNING)
log_handler_stderr = logging.StreamHandler()
log_handler_stderr.setFormatter(
    logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s] [%(process)d] [%(message)s]'))
logger.addHandler(log_handler_stderr)

# Parse command line arguments
parser = argparse.ArgumentParser(description='Nordugrid ARCHERY administration tool')
parser.add_argument('-d', '--debug', action='store', default='INFO',
                    choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'])
parser.add_argument('-s', '--source', action='append', required=True,
                    help='Select CE list source (file: and egiis: sources are supported)')
parser.add_argument('-f', '--filter', action='append', help='Add one or more filters to endpoint list. '
                                                            'Use \'-f help\' to show available filters')
parser.add_argument('-o', '--output', choices=list(_output_formatters.keys()),
                    help='Output the value to stdout according to specified type')
parser.add_argument('--json', action='store_true',
                    help='Change output format from plaintext to JSON')
parser.add_argument('--output-all', action='store_true',
                    help='Output all CEs/endpoints including inactive (filters are still applied)')
parser.add_argument('-u', '--ddns-update', action='store_true',
                    help='Invoke DNS zone direct update by means of DDNS with TSIG auth')
parser.add_argument('--domain', help='domain name of the ARCHERY endpoint to use (required for DDNS update)')
parser.add_argument('--ddns-master-ip', help='master NS IP address to contact (required for DDNS update)')
parser.add_argument('--ddns-tsig-keyfile', help='TSIG keyfile (required for DDNS update)')
cmd_args = parser.parse_args()

# Set requested logging level
logger.setLevel(getattr(logging, cmd_args.debug, 20))

# Check DDNS update required options before doing anything
if cmd_args.ddns_update:
    # check for domain
    if cmd_args.domain is None:
        logger.error('Domain name (--domain) is required to use DDNS update')
        sys.exit(1)
    domain = cmd_args.domain
    # check for master nameserver IP
    if cmd_args.ddns_master_ip is None:
        logger.error('Name server master IP to communicate (--ddns-master-ip) is required to use DDNS update')
        sys.exit(1)
    nameserver = cmd_args.ddns_master_ip
    # check for keyring
    if cmd_args.ddns_tsig_keyfile is None:
        logger.error('TSIG keyfile (--ddns-tsig-keyfile) is required to use DDNS update')
        sys.exit(1)
    else:
        try:
            logger.debug('Reading TSIG key from %s', cmd_args.ddns_tsig_keyfile)
            with open(cmd_args.ddns_tsig_keyfile, 'r') as tsig_f:
                keyring_str = tsig_f.readline()
                keyring_s = keyring_str.split(':')
                if len(keyring_s) != 2:
                    logger.error('Failed to parse TSIG keyfile %s. Expected format is keyname:secret',
                                 cmd_args.ddns_tsig_keyfile)
                    sys.exit(1)
                logger.debug('TSIG key %s has been successfully read', keyring_s[0])
                keyring_dict = {keyring_s[0]: keyring_s[1]}
        except EnvironmentError as err:
            logger.error('Failed to read TSIG keyfile %s. Error: %s', cmd_args.ddns_tsig_keyfile, err)
            sys.exit(1)

# Parse filters for fetching endpoints
applied_filters = []
if cmd_args.filter is not None:
    for f in cmd_args.filter:
        if f == 'help':
            print('Supported filters are:')
            for _, fclass in _filters.items():
                fci = fclass()
                fci.help()
            sys.exit(0)
        fdef = f.split(':', 1)
        ftype = fdef[0]
        fargs = fdef[1] if len(fdef) > 1 else ''
        if ftype not in list(_filters.keys()):
            logger.error('Ignoring bad filter definition: %s', f)
            continue
        fclass = _filters[ftype]
        fobj = fclass(fargs)
        applied_filters.append(fobj)

# Get CE list from defined sources
ce_list = []
for source in cmd_args.source:
    if source.startswith('file:'):
        logger.info('Obtaining CE list from file: %s', source[5:])
        ce_list += get_file_celist(source[5:])
    elif source.startswith('egiis:'):
        logger.info('Obtaining CE list from EGIIS URL: %s', source[6:])
        ce_list += get_egiis_celist(source[6:])
    else:
        logger.error('Unsupported CE list source: %s', source)
logger.debug('Fetched CE list to work with: %s', ', '.join(ce_list))

# Fetching endpoints info from CE's LDAP GLUE2
endpoints = {}
logger.info('Fetching endpoints info from CE\'s LDAP GLUE2')
for ce in ce_list:
    endpoints[ce] = get_ce_endpoints_glue2(ce, filters=applied_filters)

# Invoke DDNS update if requested
if cmd_args.ddns_update:
    logger.info('Sending update to DNS master %s via DDNS protocol (using TSIG key %s)',
                nameserver, list(keyring_dict.keys())[0])
    ddns_update(domain, nameserver, keyring_dict, endpoints)

# Output information if requested
if cmd_args.output:
    formatter_f = _output_formatters[cmd_args.output]
    formatter_f(endpoints, cmd_args)
