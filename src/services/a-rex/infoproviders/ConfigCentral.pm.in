package ConfigCentral;

# Builds an intermediate config structure used by infoproviders.
# OBS: the structure is NOT the same as arc.conf.

use strict;
use warnings;
use File::Basename;
use Sys::Hostname;

# added to parse JSON stuff
binmode STDOUT, ":utf8";
use utf8;

use XML::Simple;
use Data::Dumper qw(Dumper);
use JSON::XS;
#use Data::Dumper::Concise;

use IniParser;
use InfoChecker;
use LogUtils;

# while parsing, loglevel is WARNING (the default)
our $log = LogUtils->getLogger(__PACKAGE__);

#######################################################################
## Block dependencies
#######################################################################

my $blockdependencies = {
    'infosys/cluster' => ['infosys'],
    'infosys/ldap' => ['infosys'],
    'infosys/nordugrid' => ['infosys/ldap'],
    'infosys/glue2' => ['infosys'],
    'infosys/glue2/ldap' => ['infosys/glue2','infosys/ldap'],
};



######################################################################
# Legacy Internal representation of configuration data after parsing #
######################################################################

my $lrms_options = {
    pbs_bin_path => '*',
    pbs_log_path => '*',
    dedicated_node_string => '*',
    condor_bin_path => '*',
    condor_config => '*',
    condor_rank => '*',
    sge_bin_path => '*',
    sge_root => '*',
    sge_cell => '*',
    sge_qmaster_port => '*',
    sge_execd_port => '*',
    lsf_bin_path => '*',
    lsf_profile_path => '*',
    ll_bin_path => '*',
    slurm_bin_path => '*',
    slurm_wakeupperiod => '*',
    boinc_db_host => '*',
    boinc_db_port => '*',
    boinc_db_name => '*',
    boinc_db_user => '*',
    boinc_db_pass => '*'
};
my $lrms_share_options = {
    queue_node_string => '*',
    condor_requirements => '*',
    sge_jobopts => '*',
    lsf_architecture => '*',
    ll_consumable_resources => '*'
};
my $xenv_options = {
    Platform => '*',
    Homogeneous => '*',
    PhysicalCPUs => '*',
    LogicalCPUs => '*',
    CPUVendor => '*',
    CPUModel => '*',
    CPUVersion => '*',
    CPUClockSpeed => '*',
    CPUTimeScalingFactor => '*',
    WallTimeScalingFactor => '*',
    MainMemorySize => '*',
    VirtualMemorySize => '*',
    OSFamily => '*',
    OSName => '*',
    OSVersion => '*',
    VirtualMachine => '*',
    NetworkInfo => '*',
    ConnectivityIn => '*',
    ConnectivityOut => '*',
    Benchmark => [ '*' ],
    OpSys => [ '*' ],
    nodecpu => '*',
};
my $share_options = {
    MaxVirtualMemory => '*',
    MaxSlotsPerJob => '*',
    SchedulingPolicy => '*',
    Preemption => '*',
    totalcpus => '*',
    defaultmemory => '*',
    AdvertisedVO =>  [ '*' ],
    maxcputime => '*',
    maxwalltime => '*',
    mincputime => '*',
    minwalltime => '*'
};
my $cache_options = {
   cachedir => [ '*' ],
   cachesize => '*'
};

my $common_options = {
    arcversion => '',
    hostname => '*',
    x509_host_key => '*', 
    x509_host_cert => '*',
    x509_cert_dir => '*',
    x509_cert_policy => '',
    enable_perflog_reporting => '*',
    perflogdir => '*',
    # TODO: Maxload is about max downloadable streams. Most likely this is now configured via datastaging. Used for MaxStageIn|OutStreams.
    #maxload => '*',
};
my $sshcommon_options = {
    remote_user => '*',
    remote_host => '*',
    remote_sessiondir => '*',
    private_key => '*',
};

my $ldap_infosys_options = {
    enabled => '',
    port => '*',
    infosys_ldap_run_dir => '*',
    validity_ttl => '*',
    # These values have been checked to be used by infoproviders.
    user => '*',
    bdii_run_dir => '*',
    bdii_log_dir => '*',
    bdii_tmp_dir => '*',
    bdii_var_dir => '*',
    bdii_update_pid_file => '*'
    ## TODO: Do the infosys need to know this number? check InfosysHelper.
    ## fix this elsewere, the value should be set according to the formula below
    ## not used directly by infoproviders, maybe by bdii config?
    ## this is probably done in the startup script, is called max_cycle
    ## bdii_read_timeout = number - Sets BDII_READ_TIMEOUT in bdii configuration file
    ## default: $bdii_provider_timeout + $infoproviders_timelimit + $wakeupperiod
    #bdii_read_timeout=300
};

# [arex] subblocks
my $wsjobs_options = { 
    allownew => '*',    
    enabled => ''
}; 

my $ws_options = {
    enabled => '',
    wsurl => '*',
    jobs => { %$wsjobs_options } 
};

my $admindomain_options = {
    Name => '*',
    Description => '*',
    WWW => '*',
    Distributed => '*',
    Owner => '*',
    OtherInfo => '*',
};

my $glue2_options = {
    enabled => '',
    computingservice_qualitylevel => '*'
};

my $arex_options = {
    enabled => '',
    user => '',
    defaultttl => '*',
    logfile => '*',
    loglevel => '*', 
    infoproviders_timelimit => '*',
    port => '*',
    arexhostport => '',
    controldir => '',
    sessiondir => [ '' ],
    runtimedir => '*',
    shared_filesystem => '*',
    shared_scratch => '*',
    scratchdir => '*',
    maxjobs => '*',
    wakeupperiod => '*',
};

# # # # # # # # # # # # # #

my $config_schema = {
    
    ttl => '*',

    admindomain => { %$admindomain_options },   
    
    %$common_options,
    
    # TODO: what to do with these? add ssh block?
    %$sshcommon_options,

    # service is a mix of nordugrid "cluster" and glue2 concepts, taking info from different sources.
    # Translate/copy just what is needed from infosys/cluster
    service => {
        OtherInfo => [ '*' ],
        StatusInfo => [ '*' ],
        Downtime => '*',
        ClusterName => '*',
        ClusterAlias => '*',
        ClusterComment => '*',
        ClusterOwner => [ '*' ],
        AdvertisedVO => [ '*' ],
        LocalSE => [ '*' ],
        QualityLevel => '',
        # TODO: such hashes might make odd options bypass the checks, review InfoChecker
        # These below are repeated here to implement infosys/cluster level options that
        # apply to all xenvs and shares
        %$xenv_options,
        %$share_options
    },
    location => {
        Name => '*',
        Address => '*',
        Place => '*',
        Country => '*',
        PostCode => '*',
        Latitude => '*',
        Longitude => '*',
    },
    contacts => [ {
        Name => '*',
        OtherInfo => [ '*' ],
        Detail => '',
        Type => '',
    } ],
    accesspolicies => {
        '*' => {
            Rule => [ '' ],
            UserDomainID => [ '' ]
        }
    },
    mappingpolicies => {
        '*' => {
           ShareName => [ '' ],
           Rule => [ '' ],
           UserDomainID => [ '' ],
        }
    },
    xenvs => {
        '*' => {
            OtherInfo => [ '*' ],
            NodeSelection => {
                Regex => [ '*' ],
                Command => [ '*' ],
                Tag => [ '*' ],
            },
            %$xenv_options
        }
    },
    shares => {
        '*' => {
            Description => '*',
            OtherInfo => [ '*' ],
            MappingQueue => '',
            ExecutionEnvironmentName => [ '' ],
            %$share_options,
            %$lrms_share_options
        }
    },

    lrms => {
        lrms => '',
        defaultqueue => '*',
        lrmsconfig => '*',
        %$lrms_options,
        %$lrms_share_options
    },
    infosys => {
        enabled => '',
        allowaccess => {
          enabled => '*'
          },
        nordugrid => {
          enabled => '*'
        }, 
        logfile => '*',  
        loglevel => '*',
        validity_ttl => '*',
        ldap => { 
            %$ldap_infosys_options,
        },
        glue2 => {
           %$glue2_options,
           ldap => {
                enabled => '',
                showactivities => '*'
           }
        }
    },
    arex => {
        %$arex_options,
        ws => { %$ws_options },
        cache => { %$cache_options }
    },
};

my $allbools = [ qw(
                 Homogeneous VirtualMachine
                 ConnectivityIn ConnectivityOut Preemption
                 showactivities shared_filesystem
                 enabled allownew Distributed) ];

############################ Generic functions ###########################

# walks a tree of hashes and arrays while applying a function to each hash.
sub hash_tree_apply {
    my ($ref, $func) = @_;
    if (not ref($ref)) {
        return;
    } elsif (ref($ref) eq 'ARRAY') {
        map {hash_tree_apply($_,$func)} @$ref;
        return;
    } elsif (ref($ref) eq 'HASH') {
        &$func($ref);
        map {hash_tree_apply($_,$func)} values %$ref;
        return;
    } else {
        return;
    }
}

# Strips namespace prefixes from the keys of the hash passed by reference
sub hash_strip_prefixes {
    my ($h) = @_;
    my %t;
    while (my ($k,$v) = each %$h) {
        next if $k =~ m/^xmlns/;
        $k =~ s/^\w+://;
        $t{$k} = $v;
    }
    %$h=%t;
    return;
}

# Verifies that a key is an HASH reference and returns that reference
sub hash_get_hashref {
    my ($h, $key) = @_;
    my $r = ($h->{$key} ||= {});
    $log->fatal("badly formed '$key' element in XML config") unless ref $r eq 'HASH';
    return $r;
}

# Verifies that a key is an ARRAY reference and returns that reference
sub hash_get_arrayref {
    my ($h, $key) = @_;
    my $r = ($h->{$key} ||= []);
    $log->fatal("badly formed '$key' element in XML config") unless ref $r eq 'ARRAY';
    return $r;
}

# Set selected keys to either 'true' or 'false'
sub fixbools {
    my ($h,$bools) = @_;
    for my $key (@$bools) {
        next unless exists $h->{$key};
        my $val = $h->{$key};
        if ($val eq '0' or lc $val eq 'false' or lc $val eq 'no' or lc $val eq 'disable') {
            $h->{$key} = '0';
        } elsif ($val eq '1' or lc $val eq 'true' or lc $val eq 'yes' or lc $val eq 'enable' or lc $val eq 'expert-debug-on') {
            $h->{$key} = '1';
        } else {
            $log->error("Invalid value for $key");
        }
    }
    return $h;
}

sub move_keys {
    my ($h, $k, $names) = @_;
    for my $key (@$names) {
        next unless exists $h->{$key};
        $k->{$key} = $h->{$key};
        delete $h->{$key};
    }
}

sub rename_keys {
    my ($h, $k, $names) = @_;
    for my $key (keys %$names) {
        next unless exists $h->{$key};
        my $newkey = $names->{$key};
        $k->{$newkey} = $h->{$key};
        delete $h->{$key};
    }
}

# Takes two hash references and merges values
# the value of hash2 is taken if the value in 
# hash1 is not defined
# usage: merge_hash_values(hash1,hash2)
sub merge_hash_values {
    my ($hash1,$hash2) = @_;
    for my $key (keys %{$hash2}) {
        $hash1->{$key} = $hash2->{$key} if ((not defined $hash1->{$key}) || ($hash1->{$key} eq ''));
        # attempt to merge recursively
        # merge_hash_values($hash1->{$key},$hash2->{$key}) if (ref $key eq ref {});
    }
}

##################### Read config via arcconfig-parser ################

# execute parser and get json data
sub read_json_config {
    my ($arcconf) = @_;
    
    # get the calling script basepath. Will be used to
    # find external scripts like arcconfig-parser.
    my $libexecpath = ($ENV{'ARC_LOCATION'} || '@prefix@') . '/@pkglibexecsubdir@';
    
    my $jsonconfig='';
    { 
      local $/; # slurp mode
       open (my $jsonout, "$libexecpath/arcconfig-parser -e json --load -r $arcconf |") || $log->error("Python config parser error: $! at line: ".__LINE__." libexecpath: $libexecpath");
       $jsonconfig = <$jsonout>;
       close $jsonout;
    }
    my $config = decode_json($jsonconfig);
    #print Dumper($config);
    
    return $config;
}

#
# Removes spaces at beginning and end from all config values
# and config names (such as queue:\s\squeuename\s*)    
# 
sub strip_spaces {
    my ($jsonconf) = @_;
    
    for my $key (keys %{$jsonconf}) {
        # recur if inner values
        if (ref($jsonconf->{$key}) eq 'HASH') {
            strip_spaces($jsonconf->{$key});
        } elsif (ref($jsonconf->{$key}) eq 'ARRAY') {
              # strip spaces from array elements
              for my $item (@{$jsonconf->{$key}}) {
                  $item =~ s/^\s+|\s+$//g;
              }
        } elsif ($jsonconf->{$key} =~ /^\s*(.*)\s*$/) {
                 my $newvalue = $1;
                 $newvalue =~ s/^\s+|\s+$//g;
                 $jsonconf->{$key} = $newvalue;
        }
        # change key once back from recursion if it contains spaces
        if ($key =~ /\s*(queue|authgroup)\s*:\s*(.*)\s*/) {
           my $prefix = "$1:";
           my $stripstring = $2;
           $stripstring =~ s/^\s+|\s+$//g;
           my $newkey="$prefix$stripstring";
           $jsonconf->{$newkey} = $jsonconf->{$key};
           # not needed as the reference is copied. But I don't trust it.
           #delete $jsonconf->{$key};
        }
    }
}

#
# Reads the json config file passed as the first argument and produces a config
# hash conforming to $config_schema. 
#
sub build_config_from_json {
    my ($file) = @_;
    
    my $jsonconf = read_json_config($file);

    strip_spaces($jsonconf);
    
    set_defaults($jsonconf);

    
    # Those values that are the same as in arc.conf will 
    # be copied and checked.
    my $config ||= {};
    # service is an aggregation of the contents of infosys/cluster and GLUE2 relevant info
    $config->{service} ||= {};
    
    ## This below is mostly GLUE2, but we decided not to create a dedicated block.
    $config->{location} ||= {};
    $config->{contacts} ||= [];
    $config->{accesspolicies} ||= {};   
    $config->{mappingpolicies} ||= {};
    $config->{xenvs} ||= {};
    $config->{shares} ||= {};

    # start of restructured pieces of information
    $config->{infosys} ||= {};
    $config->{arex} ||= {};
    $config->{lrms} ||= {};
    #  end of restructured pieces of information
    
    # [common] options can be retrieved directly using $config->{optionname}
    my $common = $jsonconf->{'common'};
    move_keys $common, $config, [keys %$common_options];

    # TODO: not for arc7.0. Create a mapping hash eventually if we need 
    # mapped users info.
    # new mapping block (just move to the top config as it was before)
    #my $mapping = $jsonconf->{'mapping'};
    #move_keys $mapping, $config, [keys %$common_options];
    
    my $lrms = $jsonconf->{'lrms'};
    # some options in lrms, moved to $config for  backward compatibility, 
    # should be moved to {lrms} instead - 2024 is this done?
    #move_keys $lrms, $config, [keys %$lrms_options, keys %$lrms_share_options];
    move_keys $lrms, $config->{'lrms'}, [keys %$lrms];
    move_keys $lrms, $config->{'lrms'}, [keys %$lrms_options, keys %$lrms_share_options];
    
    # Parsing for default queue
    my ($lrmsname, $defaultqueue) = split /\s+/, $config->{lrms}{lrms} || '';
    $config->{'lrms'}{'lrms'} = $lrmsname; 
    $config->{'lrms'}{'defaultqueue'} = $defaultqueue if defined $defaultqueue;

    my $arex = $jsonconf->{'arex'};
    move_keys $arex, $config->{'arex'}, [keys %$arex];
    
    my $ssh = $jsonconf->{'ssh'};
    move_keys $ssh, $config, [keys %$sshcommon_options];
        
    my $infosys = $jsonconf->{'infosys'};
    move_keys $infosys, $config->{'infosys'}, [keys %$infosys];
        
    rename_keys $infosys, $config, {port => 'SlapdPort'};
    move_keys $infosys, $config, [keys %$ldap_infosys_options];

    # check that the above generated required information
    $log->error("No control directory configured") unless $config->{arex}{controldir};
    
    if (defined $jsonconf->{'arex/ws'}) {
       my $arexws = $jsonconf->{'arex/ws'};
       $config->{arex}{ws} ||= {};
       move_keys $arexws, $config->{arex}{ws}, [keys %$ws_options];
    }
    
     # handle ws endpoint information for use inside infoproviders
     if (defined $config->{arex}{ws}{wsurl}) {
        $config->{arex}{ws}{wsurl} =~ m{^(https?)://([^:/]+)(?::(\d+))?(.*)};
        my ($proto,$host,$port,$mountpoint) = ($1,$2,$3,$4);
        $port ||= 80 if $proto eq "http";
        $port ||= 443 if $proto eq "https";
        $config->{arex}{port} = $port;
        $config->{arex}{arexhostport} = "$host:$port";
    } 

    $config->{arex}{ws}{jobs} ||= {};
    if (defined $jsonconf->{'arex/ws/jobs'}) {
        my $arexwsjobs = $jsonconf->{'arex/ws/jobs'};
        move_keys $arexwsjobs, $config->{arex}{ws}{jobs}, [keys %$wsjobs_options];
        $config->{arex}{ws}{jobs}{enabled} = 1;
    } else {
        $config->{arex}{ws}{jobs}{enabled} = 0;
    }

   $config->{arex}{cache} ||= {};
    if (defined $jsonconf->{'arex/cache'}) {
       my $cacheopts = $jsonconf->{'arex/cache'};
       move_keys $cacheopts, $config->{arex}{cache}, [keys %$cache_options];
    }
    
    $config->{arex}{cache}{cleaner} ||= {};
    if (defined $jsonconf->{'arex/cache/cleaner'}) {
       my $cacheopts = $jsonconf->{'arex/cache/cleaner'};
       move_keys $cacheopts, $config->{arex}{cache}, [keys %$cache_options];
    }

    # LDAP and BDII config
    if (defined $jsonconf->{'infosys/ldap'}) {
        $config->{infosys}{ldap} ||= {};
        my $ldapconf = $jsonconf->{'infosys/ldap'};
        move_keys $ldapconf, $config->{infosys}{ldap}, [keys %$ldap_infosys_options];
    } else {
        $log->verbose("[infosys/ldap] block not found in arc.conf Disabling LDAP/LDIF information generation.");
    }

    # information schemas
    # NorduGRID
    if ($jsonconf->{'infosys/nordugrid'}{enabled}) {
        $config->{infosys}{nordugrid} ||= {};
        move_keys $jsonconf->{'infosys/nordugrid'}, $config->{infosys}{nordugrid}, [keys %{$config_schema->{infosys}{nordugrid}}];
    }

    ####### GLUE2
    if ( $jsonconf->{'infosys/glue2'}{enabled} ) {
        $config->{infosys}{glue2} ||= {};
        my $glue2conf = $jsonconf->{'infosys/glue2'};
        move_keys $glue2conf, $config->{infosys}{glue2}, [keys %$glue2_options];
        rename_keys $config->{infosys}{glue2}, $config->{service}, {computingservice_qualitylevel => 'QualityLevel'};
        # GLUE2 ldap
        if ( $jsonconf->{'infosys/glue2/ldap'}{enabled} ) {
           $config->{infosys}{glue2}{ldap} ||= {};
           my $glue2ldapconf = $jsonconf->{'infosys/glue2/ldap'};
           move_keys $glue2ldapconf, $config->{infosys}{glue2}{ldap}, [keys %{$config_schema->{infosys}{glue2}{ldap}}];
        }    

        # AdminDomain
        $config->{admindomain} ||= {};
        $log->warning('[infosys/glue2] section missing admindomain_name information. Default will be set to GLUE2 default UNDEFINEDVALUE.') if ($jsonconf->{'infosys/glue2'}{admindomain_name} eq 'UNDEFINEDVALUE' );
        my $admindomainconf = $jsonconf->{'infosys/glue2'};
        rename_keys $admindomainconf, $config->{'admindomain'}, {
                admindomain_name => 'Name',
                admindomain_description => 'Description',
                admindomain_www => 'WWW',
                admindomain_distributed => 'Distributed',
                admindomain_owner => 'Owner',
                admindomain_otherinfo => 'OtherInfo'
        }
    } else {
        $log->error('Infoproviders cannot continue without the [infosys/glue2] block. Please add it. Exiting...')
    }

    ### Process infosys/cluster
    my $cluster = $jsonconf->{'infosys/cluster'};
    if (%$cluster) {
        # Ignored: cluster_location, lrmsconfig
        rename_keys $cluster, $config->{location}, { cluster_location => 'PostCode' };
        rename_keys $cluster, $config->{service}, {
                                 interactive_contactstring => 'InteractiveContactstring',
                                 cluster_owner => 'ClusterOwner', localse => 'LocalSE',
                                 advertisedvo => 'AdvertisedVO', homogeneity => 'Homogeneous',
                                 architecture => 'Platform', opsys => 'OpSys', benchmark => 'Benchmark',
                                 nodememory => 'MaxVirtualMemory', middleware => 'Middleware',
                                 alias => 'ClusterAlias', comment => 'ClusterComment'};
        if ($cluster->{clustersupport} and $cluster->{clustersupport} =~ /(.*)@/) {
            my $contact = {};
            push @{$config->{contacts}}, $contact;
            $contact->{Name} = $1;
            $contact->{Detail} = "mailto:".$cluster->{clustersupport};
            $contact->{Type} = 'usersupport';
        }
        if (defined $cluster->{nodeaccess}) {
            $config->{service}{ConnectivityIn} = 0;
            $config->{service}{ConnectivityOut} = 0;
            for (split '\[separator\]', $cluster->{nodeaccess}) {
                $config->{service}{ConnectivityIn} = 1 if lc $_ eq 'inbound';
                $config->{service}{ConnectivityOut} = 1 if lc $_ eq 'outbound';
            }
        }
        # TODO: this causes possibly unsupported values like OSName, OSVersion to be moved and not renamed - fix with infochecker
        move_keys $cluster, $config->{service}, [keys %$share_options, keys %$xenv_options];
    }

    ## use hostname as cluster alias if not defined
    my $hostname = $config->{hostname};
     
    my @dns = split /\./, $hostname;
    my $shorthost = shift @dns;
    my $dnsdomain = join ".", @dns;
        
    unless (defined $config->{service}{ClusterAlias}) {
        $log->info("[infosys/cluster] alias= in arc.conf missing. Defaulting to $shorthost");
        chomp ($config->{service}{ClusterAlias} ||= $shorthost);
    }
    ## use cluster alias as cluster name. Currently we have no way to specify cluster name directly.
    $config->{service}{ClusterName} = $config->{service}{ClusterAlias};

    # remove useless objects if not set
    delete $config->{location} unless $config->{location} and %{$config->{location}};
    delete $config->{contacts} unless $config->{contacts} and @{$config->{contacts}};
    
    # Some checks about contacts
    if ($config->{contacts}) {
        for (@{$config->{contacts}}) {
            $log->warning("Contact is missing Type") and next unless $_->{Type};
            $log->warning("Contact is missing Detail") and next unless $_->{Detail};
            $log->warning("Contact Detail is not an URI: ".$_->{Detail}) and next
                unless $_->{Detail} =~ m/^\w+:/;
        }
    }
    
    # Generate initial shares and execution environments array, using configured queues
    my @qnames=();
    for my $keyname (keys %{$jsonconf}) {
       push(@qnames,$1) if $keyname =~ /queue\:(.*)/;
    }
    for my $name (@qnames) {
        my $queue = $jsonconf->{"queue:$name"};

        # at first every bare queue is a share
        my $sconf = $config->{shares}{$name} ||= {};
        $config->{shares}{$name}{MappingQueue} = $name;
        
        my $xeconf = $config->{xenvs}{$name} ||= {};
        push @{$sconf->{ExecutionEnvironmentName}}, $name;

        rename_keys $queue, $sconf, {nodememory => 'MaxVirtualMemory',
                                     comment => 'Description', 
                                     advertisedvo => 'AdvertisedVO',
                                     maxslotsperjob => 'MaxSlotsPerJob'};
        move_keys $queue, $sconf, [keys %$share_options, keys %$lrms_share_options];

        # TODO: change opsys here if needed
        rename_keys $queue, $xeconf, {homogeneity => 'Homogeneous', architecture => 'Platform',
                                      opsys => 'OpSys', osname => 'OSName',
                                      osversion => 'OSVersion', osfamily => 'OSFamily',
                                      benchmark => 'Benchmark'};
        move_keys $queue, $xeconf, [keys %$xenv_options];
        
        # This unsupported option was meant to select a group of nodes for a queue 
        # Since arc 6.6 this is autodiscovered from the batch system for some LRMS.
        # It may be useful in cloud context, so kept for now
        $xeconf->{NodeSelection} = {};
    }

    # At least one queue must be defined. Maybe this can be relaxed.
    $log->error("No queue or ComputingShare configured") unless %{$config->{shares}};
    $log->error("GLUE2: defaultqueue set to nonexistent ComputingShare") 
      if $config->{lrms}{defaultqueue} and not $config->{shares}{$config->{lrms}{defaultqueue}};


    # fire warning if GLUE2 Service Quality Level is not good
    if (defined $config->{service}{QualityLevel}) {
        my $qualitylevelstring = $config->{service}{QualityLevel};
        my $closedenumeration = {'development' => '1',
                                 'pre-production' => '1',
                                 'production' => '1',
                                 'testing' => '1'
                                 };
        unless (defined $closedenumeration->{$config->{service}{QualityLevel}}) {
             my @enum = keys %$closedenumeration;
             $log->error("computingservice_qualitylevel contains \"$qualitylevelstring\" which is an invalid value. Allowed value is one of: @enum");
        }
    }

    # This only happens when no queue is configured. At the moment every queue has its own execution env
    $log->error("No ExecutionEnvironment configured") unless %{$config->{xenvs}};

    # ExecutionEnvironments are automatically discovered in some LRMS since arc6.6
    # However manual selection could be useful in the future (for example cloud environments) so this code is kept.
    # Cross-check ExecutionEnvironment references
    for my $s (values %{$config->{shares}}) {
        next unless $s->{ExecutionEnvironmentName};
        for my $group (@{$s->{ExecutionEnvironmentName}}) {
            $log->error("ComputingShare associated with non-existent ExecutionEnvironment: $group")
                unless $config->{xenvs}{$group};
        }
    }
    for my $s (values %{$config->{xenvs}}) {
        delete $s->{NodeSelection} unless %{$s->{NodeSelection}};
    }

    
    ## TODO: still valid in 2024/ARC7 - this should be done together with [mapping] user stuff if needed
    ## TODO: This code below is currently not used. Access/mapping policies are currently
    #        generated in ARC1ClusterInfo.pm, but this information is mostly static and
    #        can be generated already now, simplifying ARC1ClusterInfo.pm. However simplification is not much.
    #        Also, this is strictly GLUE2, so maybe it should be confined in ARC1ClusterInfo.pm after all...
    # TODO: create shares based on configured VOs in ConfigCentral? Is this possible/good?)
    #        Can these these checks be done by InfoChecker?
    # Cross-check MappingPolicy references and move them to the share where they belong
    
    # Initialize policies data based on authorization information.
    # This might be extended in the future for more complex scenarios. For now
    # only VO based ones are built.
    
    #my %queuenamesset = map { $_ => '1' } (keys %{$config->{shares}});
    #
    #if (defined $config->{service}{AuthorizedVO}) {
    #    for my $policy (@{$config->{service}{AuthorizedVO}}) {
    #        $config->{mappingpolicies}{$policy} ||= {};
    #       $config->{mappingpolicies}{$policy}{Scheme} = 'basic;';
    #       $config->{mappingpolicies}{$policy}{Rule} = [ "vo:$policy" ];
    #       $config->{mappingpolicies}{$policy}{queues} = Storable::dclone(\%queuenamesset);
    #
    #        $config->{accesspolicies}{$policy} ||= {};
    #        $config->{accesspolicies}{$policy}{Scheme} = 'basic;';
    #        $config->{accesspolicies}{$policy}{Rule} = [ "vo:$policy" ];
    
    #    }
    #}
    
    #for my $queue (keys %queuenamesset) {
    #    if (defined $config->{shares}{$queue}{authorizedvo}) {
    #        for my $policy (@{$config->{shares}{$queue}{authorizedvo}}) {
    #            #$log->debug("$policy".Dumper($config->{mappingpolicies}));
    #            $config->{mappingpolicies}{$policy} ||= {};
    #            $config->{mappingpolicies}{$policy}{Scheme} = 'basic';
    #            $config->{mappingpolicies}{$policy}{Rule} = [ "vo:$policy" ];
    #            $config->{mappingpolicies}{$policy}{queues}{$queue} = '1';
    #
    #            $config->{accesspolicies}{$policy} ||= {};            
    #            $config->{accesspolicies}{$policy}{Scheme} = 'basic';
    #            $config->{accesspolicies}{$policy}{Rule} = [ "vo:$policy" ];
    #        }
    #    }
    #}
    
    # Disable this for now, but it should replace similar code in ARC1ClusterInfo.pm    
    #for my $s (keys %{$config->{mappingpolicies}}) {
        ## generate new share names and their data
        #for my $queuename (keys %{$config->{mappingpolicies}{$s}{queues}}) {
            #my $newsharename = $queuename.'_'.$s;
            ## temporary until we fix mappingqueues properly
            #$config->{shares}{$newsharename} = Storable::dclone($config->{shares}{$queuename});
            ## TODO: add this to the other shares too!
            #$config->{shares}{$newsharename}{MappingQueue} = $queuename;
        #};
    #}

    ## Final cleanup of the config datastructure

    # Create a list with all multi-valued options based on $config_schema.
    my @multival = ();
    hash_tree_apply $config_schema, sub { my $h = shift;
                                           for (keys %$h) {
                                               next if ref $h->{$_} ne 'ARRAY';
                                               next if ref $h->{$_}[0]; # exclude deep structures
                                               push @multival, $_;
                                           }
                                     };
    # Transform multi-valued options into arrays
    hash_tree_apply $config, sub { my $h = shift;
                                   while (my ($k,$v) = each %$h) {
                                       next if ref $v; # skip anything other than scalars
                                       $h->{$k} = [split '\[separator\]', $v];
                                       unless (grep {$k eq $_} @multival) {
                                           $h->{$k} = pop @{$h->{$k}}; # single valued options, remember last defined value only
                                       }
                                   }
                             };

    hash_tree_apply $config, sub { fixbools shift, $allbools };

    return $config;
}


#
# Infoproviders config parser. It takes in input a json file which 
# represents arc.conf and manipulates it to prepare information.
#
sub parseConfig {
    my ($file,$arc_location) = @_;
    my $config;
    
    $config = build_config_from_json($file);

    #print Dumper($config);

    LogUtils::level($config->{infosys}{loglevel}) if $config->{infosys}{loglevel};

    my $checker = InfoChecker->new($config_schema);
    my @messages = $checker->verify($config,1);
    $log->verbose("config key config->$_") foreach @messages;
    $log->verbose("Some required config options are missing or not used by infosys") if @messages;

    return $config;
}

## subblock_check_required(jsonconfig, block, requiredblock)
# Checks if the parent block is enabled and sets the enable flags accordingly

sub subblock_check_required {
    my ($config, $block) = @_;
    my @dependencyarray = @{$blockdependencies->{$block}};
    if ($config->{$block}{enabled}) {
        $config->{$block}{enabled} = 0;
        for my $requiredblock (@dependencyarray) {
            $log->debug("Checking $block, enabled=$config->{$block}{enabled}, $requiredblock, enabled=$config->{$requiredblock}{enabled}");
            unless ($config->{$requiredblock}{enabled}) {
                $log->error("required [$requiredblock] block not found but [$block] defined. Please define [$requiredblock]. Exiting");
            } else {
            $config->{$block}{enabled} = 1;
            } 
        }
    }
}

## The defaults come from the parser, but due to a PERL side effect in scanning
# hashes here we add information about enable/disable blocks.
sub set_defaults {
    my ($config) = @_;
    
    $log->debug("Applying defaults");
    
    # blocknames that are relevant for infosys and should be set to enable
    my @blocknames = ('arex',
                      'arex/ws',
                      'arex/ws/jobs',
                      'infosys',
                      'infosys/cluster',
                      'infosys/glue2',
                      'infosys/glue2/ldap',
                      'infosys/ldap',
                      'infosys/nordugrid'
                      );

    ## Fix for Perl problem with nested hashes: add an enabled item to all blocks that can be enabled and add 0 or 1 values
    for my $block (@blocknames) {
        $config->{$block}{enabled} = (defined $config->{$block}) ? 1 : 0;
    };

    #$log->debug(Dumper($config));

    # Check for dependencies
    
    for my $block (keys %$blockdependencies) {
        subblock_check_required($config,$block);
    }
    
    ## Other defaults not covered by arcconfig-parser. Might be done with an hash if more are missing. We keep it as a safety measure.

    #default ARC version taken from build. Artificiously placed in common
    $config->{arcversion}='@VERSION@';
    
    # force ldap defaults if ldap renderings are enabled in config
    $config->{infosys}{ldap}{port}='2135' if ($config->{'infosys/ldap'}{enabled});
        
    # Define a-rex endpoint. Hardcoded after ARC6. Still valid for ARC7.
    if (defined $config->{'arex/ws'}) {
       $config->{'arex/ws'}{wsurl} ||= 'https://'.$config->{hostname}.':443/arex';
    } else {
        $log->verbose("WS interface disabled. Add [arex/ws] block to enable");
    }
    
    ### end of default blocks creation
    
}

## getValueOf: Cherry picks arc.conf values
## Perl wrapper for the python parser
## input: configfile,configblock, configoption
## TODO: maybe use read_json_config for security reasons?
sub getValueOf ($$$){
    my ($arcconf,$block,$option) = @_;
    
    # get the calling script basepath. Will be used to
    # find external scripts like arcconfig-parser.
    my $libexecpath = ($ENV{'ARC_LOCATION'} || '@prefix@') . '/@pkglibexecsubdir@';
    
    my $value='';
    { 
      local $/; # slurp mode
      open (my $parserout, "$libexecpath/arcconfig-parser --load -r $arcconf -b $block -o $option |") || $log->error("Python config parser error: $! at line: ".__LINE__." libexecpath: $libexecpath");
      $value = <$parserout>;
      close $parserout;
    }

    # remove blank spaces before and after
    $value =~ s/^\s+|\s+$//g;
    # strip trailing newline
    chomp $value;
  
    return $value;

}

## isBlockPresent: returns true if block exists in config
sub isBlockPresent ($$) {
    my ($arcconf,$block) = @_;

    my $jsonconf = read_json_config($arcconf);

    if (defined $jsonconf->{$block}) { return 1 } else { return 0 } ;
}

## Todo: review, this doesn't work anymore
sub dumpInternalDatastructure ($){
    my ($configfile) = @_;
    my $config = parseConfig($configfile);
    print Dumper($config);
}

1;

__END__
