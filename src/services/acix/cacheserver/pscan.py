"""
Scans the ARC cache directory, but in another process
in order to avoid blocking the twisted reactor.

This is done in a not-so-nice way, where we create a python
in a temporary file and execute that program.
"""

from __future__ import print_function

import os
import sys
import tempfile
import time

from twisted.python import log
from twisted.internet import reactor, defer, protocol
from twisted.protocols import basic

from arc.utils import config
ARC_CONF = '/etc/arc.conf'
DATA_CACHE_SUBDIR = 'data'

SCAN_PROGRAM_DUMP = '''#generated by arc cacheindex

from __future__ import print_function

import os
import shelve
import tempfile
import time

f = None
t = time.time()
dump_file = '%s'
if dump_file:
    f = tempfile.NamedTemporaryFile('wt', delete=False)
    m = shelve.open(tempfile.gettempdir() + '/ARC-ACIX/.db')

for dirpath, dirnames, filenames in os.walk('%s'):
    for filename in filenames:
        if filename.endswith('.meta') and os.path.exists(os.path.join(dirpath, filename[:-5])):
            url = dirpath.rsplit('/')[-1] + filename.split('.')[0]
            print(url + "\\r\\n", end=' ')
            if dump_file and time.time() < t + 300: # Don't spend more than 5 mins looking up URLs
                try:
                    murl = m[url]
                except KeyError:
                    # first line of meta is url
                    murl = ''
                    with open(os.path.join(dirpath, filename), 'rt') as mf:
                        murl = mf.readline().strip()
                        m[url] = murl
                f.write(murl+'\\n')
if dump_file:
    f.close()
    m.close()
    os.rename(f.name, dump_file)
'''


class URLReceiver(basic.LineReceiver):

    def __init__(self, filter):
        self.filter = filter

    def lineReceived(self, line):
        self.filter(line.strip())



class ScanProtocol(protocol.ProcessProtocol):

    def __init__(self, filter, d):
        self.url_receiver = URLReceiver(filter)
        self.d = d

    def outReceived(self, data):
        self.url_receiver.dataReceived(data)

    def errReceived(self, data):
        log.msg("Error data received from scanning program. Oh noes: %s" % data)

    def processEnded(self, reason):
        if reason.value.exitCode == 0:
            self.d.callback(None)
            return # everything is just peachy

        log.err(reason)
        self.d.callback(reason)



def getARCCacheDirs():

    config.parse_arc_conf(os.environ['ARC_CONFIG'] if 'ARC_CONFIG' in os.environ else ARC_CONF)
    cache_dirs = config.get_value('cachedir', 'arex/cache', force_list=True)
    # First value is cachedir, second value can be 'drain'
    cache_dirs = [c.split()[0] for c in cache_dirs] if cache_dirs else []
    return cache_dirs


class CacheScanner(object):

    def __init__(self, cache_dir=[], cache_dump=False):

        if not cache_dir:
            cache_dir = getARCCacheDirs()

        self.cache_dir = cache_dir
        self.cache_dump = cache_dump


    def dir(self):
        return self.cache_dir


    def scan(self, filter):

        defs = []
        dump_file = ''
        if self.cache_dump:
            dump_file = '%s/ARC-ACIX/%s' % (tempfile.gettempdir(), str(int(time.time())))
            try: os.mkdir('%s/ARC-ACIX' % tempfile.gettempdir())
            except: pass

        for cd in self.cache_dir:
            program = SCAN_PROGRAM_DUMP % (dump_file, cd)

            tf = tempfile.NamedTemporaryFile('wt')
            tf.write(program)
            # ensure file content is in kernel before spawning process
            tf.flush()

            d = defer.Deferred()
            pp = ScanProtocol(filter, d)
            pt = reactor.spawnProcess(pp, sys.executable, args=[sys.executable, tf.name])

            def err(failure):
                log.err(failure)
                return failure

            def passthru(result, _):
                return result

            d.addErrback(err)
            # The semantics of the temporary file is that it will automatically
            # get deleted once it gets garbage collected. This means that if we
            # don't use the tf variable or set the delete flag to False, the
            # file will get deleted before we start using it. Unfortuantely
            # Python 2.5 and earlier does not support the delete flag, so
            # instead we keep the variable for the temporary file in use,
            # dealying its deletion until the filter has been generated, hence
            # the bogus passthru.
            d.addBoth(passthru, tf)
            defs.append(d)

        return defer.DeferredList(defs)



@defer.inlineCallbacks
def main():
    import sys, time

    #cache_dirs = sys.argv[2:]
    #print "Cache dirs", cache_dirs

    class Count(object):
        def __init__(self):
            self.count = 0
        def gotHash(self, hash):
            print(hash)
            self.count += 1

    c = Count()


    t0 = time.time()
    #yield CacheScanner(cache_dirs).scan(c.gotHash)
    yield CacheScanner().scan(c.gotHash)
    td = time.time() - t0

    print("Scan time:", td)
    print("Objects scanned: ", c.count)

    reactor.stop()


if __name__ == '__main__':
    reactor.callWhenRunning(main)
    reactor.run()

