\chapter{The Time Web Service}


The first implementation of a Web Service will be a simple time service. 
When the service receives a request of a client, it will respond with a string containing the system time.
For simplicity, the service will not parse the request but always return the current time.
It is therefore easier than the example of an Echo Web Service which additionally has to extract the incoming message in order to get the string which shall be echoed.
In the following subsections the implementation of the service and the client will be presented.\\

The source code of the examples given in this tutorial are available in the directory \textit{src}\footnote{If this was not shipped with the document you are reading, then please inspect\\ http://svn.nordugrid.org/trac/nordugrid/browser/arc1/trunk/doc/ws-programming-tutorial.} that accompanies the electronic version of this document.

\section{Service}

In ARC, the services are implementated as plugins such that they can easily be included or excluded by modifiying the server configuration file as it was seen in Listing~\ref{lst:arched_arcecho_xml}.
The class needed to be implemented for the Web Service inherits from the class \textit{Service}, which itself is defined in the ARC library. The proper class definition of the object \textit{TimeService} is defined in the corresponding header as shown in Listing~\ref{lst:time_arched_h}.
\lstsetCPP%
\lstinputlisting[
	label=lst:time_arched_h,
	caption={[Header file of the Time Web Service.]
	\textbf{Header file of the Time Web Service.}}
	]%
{../src/services/timeservice/timeservice.h}%
The class \textit{Service} renders the possibility to implement the method \textit{process}.
Listing~\ref{lst:time_arched_cpp} contains the C++ implementation of the Time Web Service plugin.
The key element for each plugin is the struct \textit{PluginDescriptor} named \textit{PLUGINS\_TABLE\_NAME} to be seen in line~\ref{lst_code:time_cpp_ptn}. 
%The struct defines basic entities of the service and provides a pointer to the method which is able to create an instance of the time service plugin.
Within the struct, a unique plugin name, the type of the plugin, its version and a pointer to a function which returns the instance of the time service has to be defined.
The function which returns the pointer of the instance is desclared in line~\ref{lst_code:time_cpp_get_service}. 
Within the interface an object \textit{PluginArgument} is demanded as a parameter. 
But since the plugin that is now written inherits from the class \textit{Service}, one can expect the \textit{PluginArgument} to be of a special subclass \textit{ServicePluginArgument}.
%	In the first line of the service the object is downcasted with the operator dynamic_cast
The \textit{ServicePluginArgument} provides access to the server configuration and to the message chain of the service which later may be useful.\\ 


The Time Web Service is implemented using the namespace \textit{ArcService}.
The constructor can be found in line~\ref{lst_code:time_cpp_constructor} and the deconstructor in line~\ref{lst_code:time_cpp_deconstructor}.
In the context of the simple service they don't contribute any functionality.
Only the constructor is defining the XML null-namespace for the time service.

%
%
% \textcolor{white}{newline}
\lstsetCPP%
\lstinputlisting[
	label=lst:time_arched_cpp,
	caption={[Implementation of the Time Web Service.]
	\textbf{Implementation of the Time Web Service.}}
	]%
{../src/services/timeservice/timeservice.cpp}%


The method \textit{process}, defined in line~\ref{lst_code:time_cpp_process}, realises the desired service. 
The parameters \textit{inmsg} and \textit{outmsg} are references to the incoming and outgoing messages.
Furthermore, the method \textit{process} returns the object \textit{MCCStatus} that is representing the result of the service achieved. 
Within the method \textit{process}, the service first determines the current time using a system library and then creates a SOAP payload using the object \textit{PayloadSOAP} on line~\ref{lst_code:time_cpp_process_payloadSOAP}. 
The object \textit{PayloadSOAP} provides enough functionality to create a XML message that is conform to the SOAP protocol.
The appearance of the generated request and its response will be discussed later on page~\pageref{lst:time_client_request}.\\


In the current case, the payload consists of two elements, one nested into the other.
The element \textit{time} holds the element \textit{timeResponse} which again holds the string containing the current time.
Within the line~\ref{lst_code:time_cpp_process_message_payload} the payload is stored in the message. 
When nothing unexpected happened while the message was processed, the function returns an \textit{MCCStatus} which was instanciated with the state \textit{OK}, as to be seen in line~\ref{lst_code:time_cpp_return}.\\


%The service has to be compiled into a dynamic library named \textit{libtimeservice.so}, in order
%To run the service, one has to compile the source code into a dynamic library named \textit{libtimeservice.so}.\\
%After the service is shipped into the library \textit{libtimeservice.so} it needs to be copied into the directory \textit{/tmp/arc/tutorial/lib} so it can be found by the \textit{ModuleManager} of the HED. 

To run the service, it needs to be compiled into a dynamic library. Here this is named \textit{libtimeservice.so}. The name is arbitrary but needs to be in sync with the configuration file of the HED.
For the installation, the library needs to be copied to a directory that is accessible for the HED. Any would do, but most likely one will select one that is locally mounted, in order to reduce dependencies on external hardware. For his example, the installation direction was set to \textit{/tmp/arc/tutorial/lib}. It was also specified by the \textit{ModuleManager} of the server configuration file. 
Once the server is running, the paths cannot be changed.\\


A suitable server configuration file which engages the time service is shown in Listing~\ref{lst:time_arched_xml}.
A new \textit{Path} element has been introduced into the element \textit{ModuleMananger} in line~\ref{lst_code:arched_time_moduleManager}.
It assigns the location of the created dynamic library.
On line~\ref{lst_code:arched_time_plugin} the library is explictly mentioned to be loaded as a plugin.
Another important change has been done within the \textit{Plexer} element in line~\ref{lst_code:arched_time_plexer_next}:
a rule has been introduced which redirects the request to the time service, if the path of URL is \textit{time}. 
Please note that the URL setting is case sensitive and corresponds to a regular expression.\\

\lstsetARCHEDXML
\lstinputlisting
	[
	label=lst:time_arched_xml,float=htb,
	caption={[Configuration for the Time Web Service.]
	\textbf{Configuration for the Time Web Service.}}
	]
{../src/services/timeservice/arched_timeservice.xml}

In order to start the service, the \textit{arched} command, shown in Listing~\ref{lst:arched_timeservice_ksh}, has to be used.
It is recommended to examine the log file \textit{/var/log/arched.log} if the server configuration file has been modified to  assert the start was successful.

\lstsetKSH
\begin{lstlisting}[
label=lst:arched_timeservice_ksh,float=htb,
caption={[Invokation if the arched daemon containing the Time Web Service.]
         \textbf{Invokation if the arched daemon containing the Time Web Service}}]
$ arched -c arched_timeservice.xml && echo Daemon started || echo Daemon start failed
Daemon started
\end{lstlisting}



\section{Client}\label{sec:timeservice_client}

Up to now we have implemented a server program which is running on a particular machine and waiting for other programs to ask for the time. What is still needed is the client to send the request to the server and interprete the response.
%If the server spoke the http protocol, then we could use our web browser. But it does not - wait, stop - in a way it does, but the server's SOAP envelope renders the reply rather awkward to read. \task{someone please check - SM; I think you are wrong (I like to read SOAP messages) :-) - MG}  
%     -- Even a Web Browser is operating with HTTP it is not able to produce the required SOAP body and/or header...
% \task{The server exists only once. But there may be many many clients requesting it in parallel - on the same machine or across the internet. The client may be directly controlled by a human (like the web browser) or be some cron job or other software initiating the request.} - I think that's not correct...

%\task{\#ifdef HAVE\_CONFIG\_H\#include <config.h>\#endif - habe ich entfernt... macht keinen Sinn, da keine weiteren Macros im Source Code enthalten sind... oder?}
This section is introducing the implementation of the client.
Its main task is to interprete the returned message.
In order to be able to communicate with the service providing daemon, the client needs to use an identical protocol stack.
Likewise to the HED, it will also be created dynamically using the MCCs.
But as one will see, the creation of the protocol stack on client side is very simple.\\

The source code of the client can be inspected in Listing~\ref{lst:time_client_cpp} and consists basically of one main function.
Within the line~\ref{lst_code:time_client_cpp_logger} the object \textit{Logger} is initialized.
Due to the configuration of the the \textit{Logger} in the following lines, the messages passed to it will be redirected to the standard error stream.  For the components of the protocol stack, which  are likewise loaded dynamically, one needs to specify the installation directory of ARC in line~\ref{lst_code:time_client_cpp_init}.\\
%\textcolor{white}{newline}
\lstsetCPP
\lstinputlisting
	[
	label=lst:time_client_cpp,
	caption={[Souce code of the client program.]
	\textbf{Souce code of the client program}}
	]
{../src/clients/timeclient/timeclient.cpp}
 

The URL of the service is defined in line~\ref{lst_code:time_client_cpp_url}.
It fits to the server configuration file which was shown in Listing~\ref{lst:time_arched_xml}.
The daemon is listing on port 60000 and is running on the localhost. The service itself uses HTTP and can be reached by using the path \textit{time}.
Line~\ref{lst_code:time_client_cpp_config} loads the standard configuration file, which is usually almost empty.
As a result, no additional security procedures will later be linked into the client-sided stack. 
The protocol stack is created in line~\ref{lst_code:time_client_cpp_client}. 
Thanks to the service URL the information for the configuration is completed.\\


The constructor of the class \textit{ClientSOAP} creates a SOAP client which uses HTTP and addresses the port 60000 on localhost.
If HTTPS would have been denoted within the URL, the stack would have been extended by an additional TLS protocol.
Once the client stack is ready, the request to the service can be created.
This is done in line~\ref{lst_code:time_client_cpp_message_reqeust}.
Even the appearance of the request is unimportant to the service, the message is composed of two convoluted elements \textit{time} and \textit{timeReqest}. 
The request will be processed in the next line by the method \textit{process} of the object \textit{client}. %in line~\ref{lst_code:time_client_cpp_message_response}. 
The object of the class \textit{MCCStatus} which is returned by the method indicates the success of the processing.
After verifying the response, the message will be passed to the standard out in line~\ref{lst_code:time_client_cpp_message_answer}. \\


The client program has to be compilied to an ordinary binary such that it can directly be executed from the command line.
Assure that the service is running and use the client as demonstrated in Listing~\ref{lst:time_client_ksh}.
\lstsetKSH
\begin{lstlisting}[
label=lst:time_client_ksh,float=htb,
caption={[Invokation of the time client.]
         \textbf{Invokation of the time client}}]
$ ./timeclient
Wed Feb 18 11:20:30 2009
\end{lstlisting}
The transmitted messages are shown in the Listings~\ref{lst:time_client_request} and \ref{lst:time_client_response}.
The enclosing element is \textit{Envelope} which may contain an element \textit{Header} and must contain an element \textit{Body}. %The namespace \textit{soap-env} is defined by the element \textit{envelope}
The data created by the object \textit{PayloadSOAP} is to be found within the \textit{Body}.
\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_request,float=htb,
caption={[Request message created by the client.]
         \textbf{Request message created by the client}}]
<soap-env:Envelope xmlns="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeRequest></timeRequest>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}


\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_response,float=htb,
caption={[Responce message of the service.]
         \textbf{Responce message of the service}}]
<soap-env:Envelope xmlns="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeResponse>Wed Feb 18 11:20:30 2009</timeResponse>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}


















