\documentclass[a4paper,10pt]{article}



\usepackage{ifthen}
\newboolean{brieftechdesc}
\newboolean{verbtechdesc}
\setboolean{brieftechdesc}{false}
\setboolean{verbtechdesc}{true}





%opening
\title{The Hosting Environment of the Advanced Resource Connector middleware}

\author{J. J\"{o}nemo, et al}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

The Hosting Environment Daemon (HED) is the container of all the functional components of the new generation of the Advanced Resource Connector (ARC) middleware on the server side. It is the central part in a new very lightweight incarnation of ARC that is aimed at - but not limited to - providing Web Service.

The whole design of the HED is built around the idea of flexibility and modularity. Inside HED the developer or deployer is supposed to use only as much as needed. This is why the HED mostly consists of pluggable modules with some glue between them.

Because in it's current state it mostly provides modules for building SOAP based Web Services, it is easy to think that HED is just another Web Services development framework like Axis, gSOAP, XFire or any other of numerous implementations. But instead the idea of HED is to provide framework for gluing functionalities and not a re-implementation of various standards. Effectively that means if Apache 2 web server is considered by developers as necessary for serving as frontend to services there could be plugin written which puts Apache 2 into a chain of other plugins of the HED.

In the current implementation there are no Apache or Axis plugins. That is because the developers of HED were very much concerned about making the solution lightweight and needed an implementation of the supported protocols that was both simple and lightweight. As a result essentials like SOAP and HTTP are implemented inside HED, while external software is used whenever that is found to be appropriate - as in the case of TLS, (Grid)FTP, LDAP and some other cases. ?That does not exclude possibility to have plugins using entirely external solutions either developed or accepted from third parties.?

The HED is a relatively young framework and there are quite a few rough edges and non-flexible solutions. The situation will hopefully improve with time. We would be grateful for any suggestions how to improve architecture and code of the HED. Statements like "you are doing crap, I'll better use Axis" are understood but not welcome and are usually reacted to adequately.

\section{Architecture}

\subsection{Requirements}
% Perhaps this can be an introductory part of the section without any subsection, we'll see
In the design of the HED, several goals and requirements were considered. These were weighed against each other and the factual context.

The implementation language needed to be object oriented, efficient and provide easy access to system functionality. This eventually lead to the adoption of C++. but languages such as Java and Python were also considered at an early stage.

External dependencies needed to be kept to a minimum while also taking into consideration their ubiquity or relative rarity as well as license related concerns. Software of this level of complexity must of course depend on many external libraries and components but each such dependenscy has been introduced only after due consideration.

Conservation of resources was an important goal. The present design enables many services sharing both the same process and the same network ports or even port while at the same time exhibiting a remarkably low memory footprint.

%\subsection{Functional design}

%firewalls, modularity, portability, flexibility


\subsection{Technical design}

%How was this implemented, dynamic loading, mcc...
In the technical design it turned out that the endeavours to provide dynamic loading, portability and a well tested high level memory management could all be greatly assisted by introducing glibmm - the C++ interface to the gnome projects library for memory management and related functionality. This enables the developers to write code in a way easily portable across various operating systems and architectures.

%Most of the configuration 

The HED itself means three things:
\begin{enumerate}

\item the daemon (called \texttt{arched}) which hooks up the system and initialize components the way as it is described by the configuration files. This configuration describes the components and their relations to each other. In optimal cases these single services run on any node where ARC1 is deployed and started. Without loadable components the daemon itself does nothing usefull.

\item sometimes using the HED terms to refer to collection of libraries which is used by service or other component developers. These libraries define interfaces and implement some common classes which may simplify the life of service and component developes however only few of these classes are mandatory to use to make the components and services loadable and hookable by the daemon.

\item the collection of components implementing minimal set of protocols needed for implementing so called Web Services.

Unless otherwise stated the term HED will be used through this document to refer to second option - framework of C++ classes.

\end{enumerate}


\subsubsection{MCC}

In the HED data channels to the outside world may be set up by chains of small processing units called Message Chain Components (MCCs). These work on units called Messages which represent data going in to or out of the HED. The message consists of the so called Payload which is its main content structured in a way relevant to the protocol of the corresponding MCC, and auxiliary structures such as general Attributes and Security Attributes where information relevant to each protocol is accumulated as the message progresses. Each MCC typically implements one level in the Internet Protocol suite by transforming a message to an input suitable to propagate to the next component and then performs the corresponding transformation of the response on the way back. The components are all dynamically loaded to provide maximum flexibility and extensibility. Each instance of these MCC's can be individually configured.

%As the data is passed through the individual MCCs, they each populate structures with both general attributes and special security attributes that are available at that particular protocol level.


\paragraph{Payload}

Main content of the information is transfered using the Payload part of the Message. There are no limitations on functionality of Payload object except that it must be inherited from MessagePayload class. Despite being flexible such approach would be useless. This is why HED defines three Payload interfaces and their simplest implementations. All MCCs which are distributed with the HED use, implement and extend those interfaces. Those include:

\begin{enumerate}

\item PayloadRawInterface and it's implementation PayloadRaw. This interface represents set of catenated in-memory chunks. It's meant to be used for information available as whole. And also for prepending and appending information without actually moving and copying data chunks in memory.

\item PayloadStreamInterface and it's implementation PayloadStream. It covers case of sequentially accessible information. The main purpose of that Payload is to serve protocols which define continous data stream like TCP.

\item PayloadSOAP represents parsed SOAP message. It's introduced to cover need for writing SOAP based Web Services in unified way.

\end{enumerate}


\paragraph{Security Handler}

Each MCC can also be configured to have loadable modules called Security Handlers attached to it in order to enforce security policies such as authentication and authorization or to assist such activities by gathering specialized security related information into Security Attributes. There is no strict distinction of capabilities between Security Handlers and MCCs. Both can and do populate Security Attributes. The distinction is more of logical nature. It also makes possible to have Security Handlers dealing with similar kind of information and capable of acting on different protocol levels.


\paragraph{Configuration}

The chain formulation using MCCs is up to the administrator. The chain is an ordered list of MCCs and their interconection can be described in the configuration file. Based on the configuration information the Loader components formulate the actual chain in the memory of the daemon. The MCC may implement some routing algorithm which means one MCC may have connections to multiple other MCCs. Typical scenario is that the HTTP MCC at the server side routes the HTTP messages with POST HTTP operation to a SOAP MCC but the messages with GET operation to for example a simple HTTPD service component.

Most of the MCCs has a client and a server version because the behavior of an MCC should be different depending on whether it is sitting on the server or client side. The typical scenario here is illustrated by the TCP MCC which should listen and wait for incomming messages on a socket on the server side but call \texttt{connect} on the client side.

In general every MCC have optimal and natural places in certain chains and this place cannot always be modified. For example on the server side the TCP MCC must be the first MCC in any chain where it is used and the TLS MCC should be right after the TCP MCC.

The developer who writes an MCC is free to choose any 3rd party library and component to implement the functionalty of the MCC but at least currently the MCCs should be written in the same language as the HED was written (C++) and should use the \texttt{MCC} interface class and \texttt{Message} class provided by libarcloader and libarcmessage libraries of ARC1.

\paragraph{TCP MCC}

The server TCP MCC in the HED is special in that it produces messages by listening on a socket rather than passing on messages from other MCCs. As such it spawns new threads to handle the message and its response throughout the message chain. One could envision other parallel MCCs having these properties but producing messages from other sources such as e.g. unix sockets.

\ifthenelse{\boolean{brieftechdesc}}{
This MCC can be configured as to what port to listen to.
}{}

\ifthenelse{\boolean{verbtechdesc}}{
This MCC can be configuered with one or more \texttt{<tcp:Listen>} elements which in turn contain the elements \texttt{<tcp:Port>}, \texttt{<tcp:Interface>} and \texttt{<tcp:Version>}. The \texttt{<tcp:Port>} element is mandatory and should contain an integer corresponding to the TCP port to listen to. The \texttt{<tcp:Interface>} element is optional and is meant to identify the network interface to bind to. It is currently not used. The \texttt{<tcp:Version>} element is used to specify IP version. It is optional and should if present contain the single digit 4 or 6.
}{}

\paragraph{TLS MCC}
The server TLS MCC enables ...

\ifthenelse{\boolean{brieftechdesc}}{
This MCC needs to be configured with a host certificate as well as trusted CA certificates.
}{}

\ifthenelse{\boolean{verbtechdesc}}{
The
}{}


\paragraph{HTTP MCC}

\paragraph{SOAP MCC}

\paragraph{Plexer}

In general case multiple service living in the HED so the incomming message should route to the proper service. The Plexer MCC does this job. It takes the the ENDPOINT attributes of the message collected by other MCCs compares this attribute to regular expression defined in the configuration file and forward the message to the all matching service. It acts as a dispacher. The Plexer is special in a sence that it is not a plugin but part of the libarcloader library.

\subsubsection{Services}

The services are dynamically loaded on start up just like the MCCs. They can even be regarded as special cases of MCCs in that they constitute the last link in the so called Message Chain and are attached in much the same manner as other MCCs. After being loaded, instanciated and configured by the HED, services are provided with a range of...

The services are typically expected to receive parsed SOAP messages which they service - possibly by invoking or communicating with external processes.

\subsubsection{PDC}

\subsubsection{Security Handlers}

\subsubsection{Alternative implementation languages}

In order to facilitate the developement of services, API bindings for languages other than C++ are provided and some service developement has already been done 
%Not much aboút the actual services, more about what they need to implement and what 
\section{Conclusion}

\end{document}
